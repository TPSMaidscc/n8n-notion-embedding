<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>n8n Dynamic Workflow Editor</title>

  <!-- Required scripts for the n8n preview component -->
  <script src="https://cdn.jsdelivr.net/npm/@webcomponents/webcomponentsjs@2/webcomponents-loader.js"></script>
  <script src="https://www.unpkg.com/lit@2/polyfill-support.js"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/@n8n_io/n8n-demo-component/n8n-demo.bundled.js"></script>
  
  <!-- Optional configuration file -->
  <script src="config.js" onerror="console.log('No config.js found, using defaults')"></script>

  <style>
    :root { --pad: 16px; --primary: #ff6d5a; --primary-hover: #e55a47; --secondary: #4f46e5; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
    body {
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      color: #e2e8f0;
      display: grid; 
      grid-template-rows: auto auto 1fr auto;
      gap: var(--pad);
    }
    
    .container { max-width: 100%; margin: 0 auto; padding: 0 var(--pad); }
    
    /* Header */
    header { padding: var(--pad); background: rgba(30, 41, 59, 0.8); backdrop-filter: blur(10px); border-bottom: 1px solid #334155; }
    .header-content { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 12px; }
    .title { font-size: 20px; font-weight: 700; color: var(--primary); }
    .actions { display: flex; gap: 8px; flex-wrap: wrap; }
    
    /* Configuration Panel */
    .config-panel { padding: var(--pad); background: rgba(17, 24, 39, 0.9); border-bottom: 1px solid #374151; }
    .config-content { display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: center; }
    .api-info { 
      color: #94a3b8; font-size: 14px; display: flex; align-items: center; gap: 8px;
    }
    .api-info strong { color: var(--primary); }
    
    /* Buttons */
    .btn {
      padding: 10px 16px; border-radius: 8px; border: none; cursor: pointer;
      font-weight: 500; text-decoration: none; display: inline-flex; align-items: center; gap: 8px;
      transition: all 0.2s ease; font-size: 14px; min-width: auto;
    }
    .btn-primary { background: var(--primary); color: white; }
    .btn-primary:hover { background: var(--primary-hover); transform: translateY(-1px); }
    .btn-secondary { background: var(--secondary); color: white; }
    .btn-secondary:hover { background: #4338ca; transform: translateY(-1px); }
    .btn-outline { background: transparent; color: #e2e8f0; border: 1px solid #374151; }
    .btn-outline:hover { background: #374151; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }
    
    /* Main content */
    main { min-height: 0; padding: 0 var(--pad); position: relative; }
    
    /* Workflow selector */
    .workflow-selector { 
      margin-bottom: var(--pad); padding: var(--pad); background: rgba(17, 24, 39, 0.8);
      border: 1px solid #374151; border-radius: 12px; backdrop-filter: blur(10px);
    }
    .selector-grid { display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: center; }
    .workflow-select { 
      padding: 10px 14px; background: #1f2937; border: 1px solid #374151; 
      border-radius: 8px; color: #e2e8f0; font-size: 14px; min-width: 200px;
    }
    
    /* Workflow viewer */
    .workflow-container { 
      position: relative; border-radius: 14px; overflow: hidden; 
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      min-height: 820px; /* Account for header + component height */
    }
    .preview-header {
      background: rgba(239, 68, 68, 0.1); border-bottom: 1px solid rgba(239, 68, 68, 0.2);
      padding: 12px 16px; display: flex; align-items: center; justify-content: space-between;
      color: #ef4444; font-size: 14px;
    }
    .preview-status { font-weight: 500; }
    .preview-header > div:last-child { display: flex; gap: 8px; }
    n8n-demo {
      width: 100%; height: 100%; display: block; 
      background: #0b1220; border: 1px solid #334155; min-height: 800px;
    }
    
    /* Status and loading */
    .status { 
      padding: 8px 12px; background: rgba(34, 197, 94, 0.1); color: #22c55e;
      border: 1px solid rgba(34, 197, 94, 0.2); border-radius: 6px; font-size: 12px; font-weight: 500;
    }
    .status.error { background: rgba(239, 68, 68, 0.1); color: #ef4444; border-color: rgba(239, 68, 68, 0.2); }
    .status.warning { background: rgba(245, 158, 11, 0.1); color: #f59e0b; border-color: rgba(245, 158, 11, 0.2); }
    
    .loading { display: none; align-items: center; gap: 8px; color: #94a3b8; }
    .loading.show { display: flex; }
    .spinner { 
      width: 16px; height: 16px; border: 2px solid #374151; border-top: 2px solid var(--primary); 
      border-radius: 50%; animation: spin 1s linear infinite;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    
    /* Footer */
    footer { padding: var(--pad); font-size: 12px; color: #64748b; text-align: center; }
    footer a { color: var(--primary); text-decoration: none; }
    footer a:hover { text-decoration: underline; }
    
    /* Responsive */
    @media (max-width: 768px) {
      :root { --pad: 12px; }
      .config-content { grid-template-columns: 1fr; }
      .selector-grid { grid-template-columns: 1fr; }
      .header-content { flex-direction: column; align-items: stretch; }
      .actions { justify-content: center; }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <div class="title">üöÄ n8n Dynamic Workflow Editor</div>
    <div class="actions">
        <button id="fullscreen" class="btn btn-outline" title="Full screen">
          <span>‚õ∂</span> Fullscreen
        </button>
        <a id="editLink" class="btn btn-secondary" href="#" target="_blank" rel="noopener">
          <span>‚úèÔ∏è</span> Edit in n8n
        </a>
      </div>
    </div>
  </header>

      <!-- API Key Panel -->
    <div class="config-panel">
      <div class="config-content">
        <div class="api-info">
          <span>üì° Connected to: <strong>n8n-test.teljoy.io</strong></span>
        </div>
        <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
          <button id="connectBtn" class="btn btn-primary">
            <span>üîë</span> Enter API Key & Connect
          </button>
        </div>
        <div class="loading">
          <div class="spinner"></div>
          <span>Connecting...</span>
        </div>
      </div>
    </div>

  <main>
    <!-- Workflow Selector -->
    <div class="workflow-selector">
      <div class="selector-grid">
        <select id="workflowSelect" class="workflow-select" disabled>
          <option value="">Select a workflow to load...</option>
        </select>
        <div class="actions">
          <button id="refreshBtn" class="btn btn-outline" disabled>
            <span>üîÑ</span> Refresh
          </button>
          <button id="saveBtn" class="btn btn-primary" disabled>
            <span>üíæ</span> Save Changes
          </button>
        </div>
      </div>
      <div id="statusMsg" class="status" style="display: none; margin-top: 12px;"></div>
    </div>

        <!-- Workflow Viewer -->
    <div class="workflow-container">
      <div class="preview-header" style="display: none;">
        <div class="preview-status">‚ö†Ô∏è Preview failed to load</div>
        <div>
          <button id="refreshPreviewBtn" class="btn btn-outline">
            <span>üîÑ</span> Refresh Preview
          </button>
          <button id="testLegacyBtn" class="btn btn-outline">
            <span>üß™</span> Test Legacy
          </button>
          <button id="hardResetBtn" class="btn btn-outline">
            <span>üîß</span> Hard Reset
          </button>
        </div>
      </div>
    <n8n-demo id="preview" frame="true"></n8n-demo>
    </div>
  </main>

  <footer>
    <p>
      üéØ <strong>Dynamic n8n Integration:</strong> Connect to your n8n instance to load, view, and save workflows directly.
      <br/>
      üí° Perfect for embedding in <a href="https://notion.so" target="_blank">Notion</a> or any other platform.
    </p>
  </footer>

  <script>
    // ==========================================
    // n8n Dynamic Workflow Editor
    // ==========================================
    
    class N8nDynamicEditor {
      constructor() {
        // Load configuration (optional)
        this.config = window.N8N_CONFIG || {};
        
        // Hardcode the n8n instance URL
        this.n8nUrl = 'https://corsproxy.io/?https://n8n-test.teljoy.io';
        this.apiKey = ''; // Always prompt for API key
        this.workflows = [];
        this.currentWorkflow = null;
        this.isConnected = false;
        this.autoSaveEnabled = this.config.autoSave !== false; // Default true
        this.hasUnsavedChanges = false;
        
        this.initializeElements();
        this.bindEvents();
        this.parseUrlParameters();
        this.applyBranding();
        this.initializePreviewSizing();
        
        // Check if workflow was passed via URL parameters
        this.handleUrlWorkflow();
      }
      
      initializeElements() {
        this.elements = {
          connectBtn: document.getElementById('connectBtn'),
          loading: document.querySelector('.loading'),
          workflowSelect: document.getElementById('workflowSelect'),
          refreshBtn: document.getElementById('refreshBtn'),
          refreshPreviewBtn: document.getElementById('refreshPreviewBtn'),
          testLegacyBtn: document.getElementById('testLegacyBtn'),
          hardResetBtn: document.getElementById('hardResetBtn'),
          saveBtn: document.getElementById('saveBtn'),
          statusMsg: document.getElementById('statusMsg'),
          preview: document.getElementById('preview'),
          previewHeader: document.querySelector('.preview-header'),
          fullscreenBtn: document.getElementById('fullscreen'),
          editLink: document.getElementById('editLink')
        };
      }
      
      bindEvents() {
        this.elements.connectBtn.addEventListener('click', () => this.connect());
        this.elements.workflowSelect.addEventListener('change', (e) => {
          console.log('üîÑ WORKFLOW SELECTION CHANGED - FORCING FULL REFRESH');
          this.forcePreviewRefresh();
          this.loadWorkflow(e.target.value);
        });
        this.elements.refreshBtn.addEventListener('click', () => this.refreshWorkflows());
        this.elements.refreshPreviewBtn.addEventListener('click', () => this.refreshPreview());
        this.elements.testLegacyBtn.addEventListener('click', () => this.testLegacyFallback());
        this.elements.hardResetBtn.addEventListener('click', () => {
          if (this.currentWorkflow) {
            // Use the same cleaned format as the main loading function
            const cleanedWorkflow = {
              nodes: this.currentWorkflow.nodes || [],
              connections: this.currentWorkflow.connections || {}
            };
            if (this.currentWorkflow.pinData && Object.keys(this.currentWorkflow.pinData).length > 0) {
              cleanedWorkflow.pinData = this.currentWorkflow.pinData;
            }
            if (this.currentWorkflow.meta && this.currentWorkflow.meta.instanceId) {
              cleanedWorkflow.meta = { instanceId: this.currentWorkflow.meta.instanceId };
            }
            this.hardResetComponent(cleanedWorkflow);
          } else {
            this.showStatus('‚ö†Ô∏è No workflow loaded to reset with', 'warning');
          }
        });
        this.elements.saveBtn.addEventListener('click', () => this.saveWorkflow());
        this.elements.fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
        
        // Auto-save on workflow changes (debounced)
        let saveTimeout;
        this.elements.preview.addEventListener('workflow-changed', () => {
          clearTimeout(saveTimeout);
          saveTimeout = setTimeout(() => this.autoSave(), 2000);
        });
      }
      
      forcePreviewRefresh() {
        console.log('üí• ===== FORCING COMPLETE PREVIEW REFRESH =====');
        
        // Step 1: Show loading state
        this.hidePreviewError();
        this.showStatus('üîÑ Refreshing preview...', 'info');
        
        // Step 2: Completely destroy and recreate the component
        const container = this.elements.preview.parentNode;
        const oldElement = this.elements.preview;
        
        // Remove old element completely
        container.removeChild(oldElement);
        
        // Step 3: Create brand new component
        const newElement = document.createElement('n8n-demo');
        newElement.id = 'preview';
        newElement.setAttribute('frame', 'true');
        
        // Step 4: Add it back to the DOM
        container.appendChild(newElement);
        
        // Step 5: Update our reference
        this.elements.preview = newElement;
        
        // Step 6: Re-bind events for auto-save
        this.bindPreviewEvents();
        
        console.log('‚úÖ Preview component completely refreshed and ready');
      }
      
      checkComponentState(checkName) {
        const previewElement = this.elements.preview;
        const hasWorkflowAttribute = previewElement.hasAttribute('workflow');
        const workflowValue = previewElement.getAttribute('workflow');
        
        console.log(`--- ${checkName} ---`);
        console.log('Component basic state:');
        console.log('  - Has workflow attribute:', hasWorkflowAttribute);
        console.log('  - Workflow attribute length:', workflowValue ? workflowValue.length : 0);
        console.log('  - Element innerHTML length:', previewElement.innerHTML.length);
        console.log('  - Shadow root exists:', !!previewElement.shadowRoot);
        
        let shadowContent = '';
        let hasCanvas = false;
        let hasErrors = false;
        let errorMessages = [];
        
        if (previewElement.shadowRoot) {
          shadowContent = previewElement.shadowRoot.innerHTML;
          console.log('  - Shadow root innerHTML length:', shadowContent.length);
          
          // Check for canvas or svg elements (signs of successful render)
          const canvasElements = previewElement.shadowRoot.querySelectorAll('canvas, svg, .workflow-canvas');
          hasCanvas = canvasElements.length > 0;
          console.log('  - Has canvas/svg elements:', hasCanvas, `(found ${canvasElements.length})`);
          
          // Check for any error indicators
          const errorSelectors = [
            '[data-test-id*="error"]',
            '.error',
            '[class*="error"]',
            '[class*="Error"]',
            '.n8n-toast--error',
            '.message-error',
            '.workflow-error'
          ];
          
          errorSelectors.forEach(selector => {
            const elements = previewElement.shadowRoot.querySelectorAll(selector);
            if (elements.length > 0) {
              hasErrors = true;
              elements.forEach((el, i) => {
                const msg = el.textContent || el.innerHTML || `[${selector} element ${i}]`;
                errorMessages.push(msg.trim().substring(0, 200));
                console.log(`  ‚ùå Error found (${selector}):`, msg.trim().substring(0, 100));
              });
            }
          });
          
          // Look for "Could not load" message specifically
          if (shadowContent.includes('Could not load')) {
            hasErrors = true;
            errorMessages.push('Found "Could not load" message in shadow content');
            console.log('  ‚ùå Found "Could not load" message in shadow content');
          }
        }
        
        // Overall success assessment
        const isSuccess = hasWorkflowAttribute && 
                         shadowContent.length > 500 && 
                         (hasCanvas || previewElement.innerHTML.length > 100) && 
                         !hasErrors;
        
        console.log('Component assessment:');
        console.log('  - Overall success:', isSuccess);
        console.log('  - Has content:', shadowContent.length > 500);
        console.log('  - Has visual elements:', hasCanvas);
        console.log('  - Has errors:', hasErrors);
        
        if (hasErrors && errorMessages.length > 0) {
          console.log('  - Error messages:', errorMessages);
        }
        
        // Try to get component's internal state if possible
        if (previewElement.workflow) {
          console.log('  - Component internal workflow exists');
        }
        
        return isSuccess;
      }
      
      hardResetComponent(workflowData) {
        console.log('=== HARD RESET: Recreating n8n-demo component ===');
        
        const container = this.elements.preview.parentNode;
        const oldElement = this.elements.preview;
        
        // Create completely new component
        const newElement = document.createElement('n8n-demo');
        newElement.id = 'preview';
        newElement.setAttribute('frame', 'true');
        
        // Replace the old component
        container.replaceChild(newElement, oldElement);
        
        // Update our reference
        this.elements.preview = newElement;
        
        console.log('  - Created new n8n-demo element');
        console.log('  - Setting workflow data on fresh component');
        
        // Set workflow on the fresh component
        setTimeout(() => {
          newElement.setAttribute('workflow', JSON.stringify(workflowData));
          console.log('  - Workflow set on new component');
          
          // Check if this worked
          setTimeout(() => {
            console.log('=== HARD RESET CHECK (2s) ===');
            const success = this.checkComponentState('Hard reset check');
            
            if (success) {
              console.log('‚úÖ Hard reset successful! Component is now working.');
              this.hidePreviewError();
              // Re-bind events for the new element
              this.bindPreviewEvents();
            } else {
              console.log('‚ùå Even hard reset failed. Component may be fundamentally broken.');
              this.showPreviewError();
              this.showStatus('‚ùå Preview component failed to load. Try refreshing the page.', 'error');
            }
          }, 2000);
        }, 100);
      }
      
      bindPreviewEvents() {
        // Re-bind auto-save events to the new component
        let saveTimeout;
        this.elements.preview.addEventListener('workflow-changed', () => {
          clearTimeout(saveTimeout);
          saveTimeout = setTimeout(() => this.autoSave(), 2000);
        });
      }
      
      refreshPreview() {
        console.log('üîÑ Manual refresh requested...');
        
        // Force complete refresh first
        this.forcePreviewRefresh();
        
        // Then reload the current workflow
        const selectedWorkflowId = this.elements.workflowSelect.value;
        if (selectedWorkflowId) {
          console.log('Re-loading selected workflow:', selectedWorkflowId);
          this.loadWorkflow(selectedWorkflowId);
        } else if (this.currentWorkflow) {
          console.log('Re-applying current workflow data');
          this.loadWorkflowFromData(this.currentWorkflow, 'Manual Refresh');
        } else {
          this.showStatus('‚ö†Ô∏è No workflow to refresh', 'warning');
        }
      }
      
      showPreviewError() {
        if (this.elements.previewHeader) {
          this.elements.previewHeader.style.display = 'flex';
        }
      }
      
      hidePreviewError() {
        if (this.elements.previewHeader) {
          this.elements.previewHeader.style.display = 'none';
        }
      }
      
      parseUrlParameters() {
        const urlParams = new URLSearchParams(window.location.search);
        this.urlParams = {
          // Direct workflow JSON
          workflow: urlParams.get('workflow'),
          // Workflow ID + n8n URL to load from API  
          workflowId: urlParams.get('workflowId'),
          n8nUrl: urlParams.get('n8nUrl'),
          // External workflow JSON URL
          workflowUrl: urlParams.get('workflowUrl'),
          // API key (not recommended for security, but supported)
          apiKey: urlParams.get('apiKey')
        };
      }
      
      async handleUrlWorkflow() {
        const params = this.urlParams;
        
        // Case 1: Direct workflow JSON in URL
        if (params.workflow) {
          try {
            const workflowData = JSON.parse(decodeURIComponent(params.workflow));
            this.loadWorkflowFromData(workflowData, 'URL Parameter');
            this.showStatus('‚úÖ Loaded workflow from URL parameter', 'success');
          } catch (error) {
            this.showStatus('‚ùå Invalid workflow JSON in URL parameter', 'error');
          }
        }
        
        // Case 2: Load from external JSON URL
        else if (params.workflowUrl) {
          try {
            this.showLoading(true, 'Loading workflow from URL...');
            const response = await fetch(params.workflowUrl);
            const workflowData = await response.json();
            this.loadWorkflowFromData(workflowData, 'External URL');
            this.showStatus('‚úÖ Loaded workflow from external URL', 'success');
          } catch (error) {
            this.showStatus(`‚ùå Failed to load workflow from URL: ${error.message}`, 'error');
          } finally {
            this.showLoading(false);
          }
        }
        
        // Case 3: Load from n8n API using workflow ID
        else if (params.workflowId && params.n8nUrl) {
          this.n8nUrl = params.n8nUrl;
          this.elements.n8nUrl.value = params.n8nUrl;
          
          // Prompt for API key and then load workflow
          await this.promptForApiKey();
          if (this.apiKey) {
            await this.loadWorkflowFromApi(params.workflowId);
          }
        }
      }
      
      loadWorkflowFromData(workflowData, source) {
        console.log('üîÑ ===== NEW WORKFLOW LOADING STARTED =====');
        console.log('üìç Source:', source);
        console.log('üìä Workflow Name:', workflowData?.name || 'Unnamed');
        console.log('üÜî Workflow ID:', workflowData?.id || 'No ID');
        
        this.currentWorkflow = workflowData;
        
        // Hide error initially while loading
        this.hidePreviewError();
        
        console.log('=== DETAILED WORKFLOW LOADING DEBUG ===');
        console.log('1. Source:', source);
        console.log('2. Raw API data keys:', Object.keys(workflowData || {}));
        console.log('3. Raw API data:', workflowData);
        
        // Compare with working legacy format structure
        console.log('4. API vs Legacy comparison:');
        console.log('   - API nodes count:', (workflowData.nodes || []).length);
        console.log('   - API connections count:', Object.keys(workflowData.connections || {}).length);
        console.log('   - API has pinData?', !!workflowData.pinData);
        console.log('   - API has meta?', !!workflowData.meta);
        console.log('   - API extra properties:', Object.keys(workflowData || {}).filter(k => 
          !['nodes', 'connections', 'pinData', 'meta'].includes(k)));
        
        // Create format that EXACTLY matches the working legacy workflow.json
        const legacyFormatWorkflow = {
          nodes: workflowData.nodes || [],
          connections: workflowData.connections || {}
        };
        
        // Add pinData only if it exists and has content (like legacy)
        if (workflowData.pinData && Object.keys(workflowData.pinData).length > 0) {
          legacyFormatWorkflow.pinData = workflowData.pinData;
          console.log('5. Added pinData with keys:', Object.keys(workflowData.pinData));
        } else {
          console.log('5. No pinData to add');
        }
        
        // Add meta only if it has instanceId (like legacy)
        if (workflowData.meta && workflowData.meta.instanceId) {
          legacyFormatWorkflow.meta = {
            instanceId: workflowData.meta.instanceId
          };
          console.log('6. Added meta with instanceId:', workflowData.meta.instanceId);
        } else {
          console.log('6. No meta.instanceId to add');
        }
        
        // Validate critical structure
        if (!Array.isArray(legacyFormatWorkflow.nodes)) {
          console.log('‚ö†Ô∏è FIXING: nodes is not an array!');
          legacyFormatWorkflow.nodes = [];
        }
        
        if (!legacyFormatWorkflow.connections || typeof legacyFormatWorkflow.connections !== 'object') {
          console.log('‚ö†Ô∏è FIXING: connections is not an object!');
          legacyFormatWorkflow.connections = {};
        }
        
        console.log('7. Final cleaned workflow keys:', Object.keys(legacyFormatWorkflow));
        console.log('8. Final cleaned workflow:', legacyFormatWorkflow);
        
        // Set workflow data on the fresh component (component was already refreshed)
        console.log('9. Setting workflow data on fresh component...');
        this.elements.preview.setAttribute('workflow', JSON.stringify(legacyFormatWorkflow));
        console.log('10. Workflow data set');
        
        // Check if loading was successful
        setTimeout(() => {
          console.log('=== CHECKING FRESH COMPONENT LOAD (1s) ===');
          const success = this.checkComponentState('Fresh component check');
          
          if (success) {
            console.log('‚úÖ Fresh component loaded successfully!');
            this.hidePreviewError();
            this.showStatus(`‚úÖ Preview loaded: "${workflowData.name || 'Unnamed'}"`, 'success');
          } else {
            console.log('‚ùå Even fresh component failed to load');
            this.showPreviewError();
            this.showStatus(`‚ùå Preview failed to load: "${workflowData.name || 'Unnamed'}"`, 'error');
          }
        }, 1000);
        
        // Enable save button if we have n8n connection
        if (this.isConnected) {
          this.elements.saveBtn.disabled = false;
          this.markAsSaved();
        }
        
        // Set up change detection
        this.setupChangeDetection();
        
        // Update status
        const workflowName = workflowData.name || workflowData.id || 'Unnamed';
        this.showStatus(`‚úÖ Loaded workflow "${workflowName}" from ${source}`, 'success');
      }
      
      async testLegacyFallback() {
        console.log('=== LEGACY FALLBACK TEST ===');
        try {
          const response = await fetch('workflow.json');
          const legacyWorkflow = await response.json();
          
          console.log('Legacy workflow structure analysis:');
          console.log('  - Keys:', Object.keys(legacyWorkflow));
          console.log('  - Nodes count:', legacyWorkflow.nodes?.length || 0);
          console.log('  - Connections keys:', Object.keys(legacyWorkflow.connections || {}));
          console.log('  - Has pinData:', !!legacyWorkflow.pinData);
          console.log('  - Has meta:', !!legacyWorkflow.meta);
          console.log('  - Full legacy workflow:', legacyWorkflow);
          
          // Apply legacy workflow
          this.elements.preview.setAttribute('workflow', JSON.stringify(legacyWorkflow));
          console.log('Applied legacy workflow to preview component');
          
          // Test multiple time points
          setTimeout(() => {
            console.log('=== LEGACY TEST CHECK (1s) ===');
            this.checkComponentState('Legacy fallback 1s');
          }, 1000);
          
          setTimeout(() => {
            console.log('=== LEGACY TEST CHECK (3s) ===');
            const success = this.checkComponentState('Legacy fallback 3s');
            
            if (success) {
              console.log('‚úÖ Legacy workflow.json loaded successfully!');
              this.hidePreviewError();
              this.showStatus('‚úÖ Preview loaded with legacy fallback workflow', 'success');
              
              // Compare what worked
              console.log('=== SUCCESS COMPARISON ===');
              console.log('Legacy workflow that WORKED:', JSON.stringify(legacyWorkflow, null, 2));
              
            } else {
              console.log('‚ùå Even legacy workflow.json failed to load properly');
              this.showStatus('‚ùå Preview component has deeper issues. Check browser console for details.', 'error');
              
              // This means the component itself might be broken
              console.log('=== COMPONENT DEBUGGING ===');
              console.log('n8n-demo element:', this.elements.preview);
              console.log('Component custom element defined:', !!customElements.get('n8n-demo'));
              console.log('Component loaded state:', this.elements.preview.loaded);
              console.log('Component error state:', this.elements.preview.error);
            }
          }, 3000);
          
        } catch (error) {
          console.log('Failed to load legacy workflow.json:', error);
          this.showStatus('‚ùå Could not load fallback workflow. Check browser console.', 'error');
        }
      }
      
      async loadWorkflowFromApi(workflowId) {
        try {
          this.showLoading(true, 'Loading workflow from n8n API...');
          
          let workflow;
          try {
            // Try v1 API first
            workflow = await this.makeApiCall(`/api/v1/workflows/${workflowId}`);
          } catch (error) {
            // Fall back to older API endpoint
            workflow = await this.makeApiCall(`/rest/workflows/${workflowId}`);
          }
          
          this.isConnected = true;
          this.loadWorkflowFromData(workflow, 'n8n API');
          this.elements.saveBtn.disabled = false;
          // Clean the URL for the edit link (remove proxy if present)
          const cleanUrl = this.n8nUrl.includes('corsproxy.io') 
            ? decodeURIComponent(this.n8nUrl.split('corsproxy.io/?')[1]) 
            : this.n8nUrl;
          this.elements.editLink.href = `${cleanUrl}/workflow/${workflowId}`;
          
        } catch (error) {
          this.showStatus(`‚ùå Failed to load workflow from API: ${error.message}`, 'error');
        } finally {
          this.showLoading(false);
        }
      }
      
      loadFromLocalStorage() {
        // Don't auto-load API keys - always prompt for security
        // URL is hardcoded, so no need to load from localStorage
      }
      
      applyBranding() {
        const branding = this.config.branding || {};
        
        // Update title if configured
        if (branding.title) {
          document.title = branding.title;
          document.querySelector('.title').textContent = `üöÄ ${branding.title}`;
        }
        
        // Update primary color if configured
        if (branding.primaryColor) {
          document.documentElement.style.setProperty('--primary', branding.primaryColor);
        }
        
        // Hide powered by message if configured
        if (branding.showPoweredBy === false) {
          const footer = document.querySelector('footer p');
          footer.innerHTML = 'üí° Perfect for embedding in <a href="https://notion.so" target="_blank">Notion</a> or any other platform.';
        }
      }
      
      saveToLocalStorage() {
        // Don't save API keys for security - they're always prompted for
        // URL is hardcoded, so no need to save
      }
      
      async connect() {
        this.showLoading(true, 'Connecting...');
        this.elements.connectBtn.disabled = true;
        
        try {
          // Always prompt for API key
          if (!this.apiKey) {
            await this.promptForApiKey();
          }
          
          this.showLoading(true, 'Testing connection...');
          
          // Test connection with API key
          await this.testConnection();
          this.isConnected = true;
          
          this.showLoading(true, 'Loading workflows...');
          await this.loadWorkflows();
          
          this.showStatus('‚úÖ Connected successfully!', 'success');
          this.enableWorkflowControls();
          
          // If we have a workflow from URL parameters, enable save button
          if (this.currentWorkflow) {
            this.elements.saveBtn.disabled = false;
          }
          
        } catch (error) {
          console.error('Connection failed:', error);
          
          // Provide specific error messages
          let errorMessage = error.message;
          
          if (error.message.includes('API key') || error.message.includes('401')) {
            errorMessage = 'Invalid API key. Please check your API key in n8n Settings ‚Üí Personal Access Tokens';
            this.apiKey = ''; // Clear invalid API key
          } else if (error.message.includes('404') || error.message.includes('not found')) {
            errorMessage = 'n8n API endpoints not found. Please check your n8n instance.';
          }
          
          this.showStatus(`‚ùå ${errorMessage}`, 'error');
          this.isConnected = false;
          
        } finally {
          this.showLoading(false);
          this.elements.connectBtn.disabled = false;
        }
      }
      

      
      async testConnection() {
        // Try different API endpoints to detect n8n version and capabilities
        const endpoints = [
          '/api/v1/workflows', // n8n v1+
          '/rest/workflows',   // older versions
        ];
        
        for (const endpoint of endpoints) {
          try {
            // Simple GET request to avoid CORS preflight
            const response = await fetch(`${this.n8nUrl}${endpoint}?limit=1`, {
              method: 'GET',
              headers: {
                'X-N8N-API-KEY': this.apiKey
              }
            });
            
            if (response.ok) {
              return endpoint;
            } else if (response.status === 401) {
              throw new Error('Invalid API key or insufficient permissions');
            }
          } catch (error) {
            if (error.message.includes('API key') || error.message.includes('401')) {
              throw error; // Re-throw authentication errors
            }
            // For CORS or network errors, try next endpoint
            console.warn(`Failed to connect to ${endpoint}:`, error.message);
            continue;
          }
        }
        throw new Error('Could not connect to n8n instance. Check URL, API key, and CORS configuration.');
      }
      
      async promptForApiKey() {
        // Check if API key was provided in URL (not recommended but supported)
        if (this.urlParams.apiKey) {
          this.apiKey = this.urlParams.apiKey;
          this.showStatus('‚ö†Ô∏è Using API key from URL (not recommended for security)', 'warning');
          return;
        }
        
        // Always prompt for API key for security
        const apiKey = prompt('Please enter your n8n API key for authentication:');
        if (!apiKey) {
          throw new Error('API key is required for authentication');
        }
        this.apiKey = apiKey;
        
        // Don't save API key to localStorage for security
        this.showStatus('üîê API key entered (stored securely in memory)', 'success');
      }
      
      async loadWorkflows() {
        try {
          // Try v1 API first, then fall back to older API
          let response;
          try {
            response = await this.makeApiCall('/api/v1/workflows?limit=100');
          } catch (error) {
            // Fall back to older API endpoint
            response = await this.makeApiCall('/rest/workflows?limit=100');
          }
          
          // Handle different response formats
          this.workflows = Array.isArray(response) ? response : (response.data || response.workflows || []);
          
          if (!Array.isArray(this.workflows)) {
            this.workflows = [];
          }
          
          this.populateWorkflowSelect();
          this.showStatus(`üìã Loaded ${this.workflows.length} workflows`, 'success');
          
          // Auto-load default workflow if configured
          if (this.config.defaultWorkflowId) {
            const defaultWorkflow = this.workflows.find(w => w.id === this.config.defaultWorkflowId);
            if (defaultWorkflow) {
              this.elements.workflowSelect.value = this.config.defaultWorkflowId;
              await this.loadWorkflow(this.config.defaultWorkflowId);
            }
          }
        } catch (error) {
          console.error('Failed to load workflows:', error);
          this.showStatus(`‚ùå Failed to load workflows: ${error.message}`, 'error');
          this.workflows = []; // Ensure workflows is always an array
          this.populateWorkflowSelect();
        }
      }
      
      populateWorkflowSelect() {
        const select = this.elements.workflowSelect;
        select.innerHTML = '<option value="">Select a workflow to load...</option>';
        
        this.workflows.forEach(workflow => {
          const option = document.createElement('option');
          option.value = workflow.id;
          option.textContent = `${workflow.name} ${workflow.active ? 'üü¢' : 'üî¥'}`;
          select.appendChild(option);
        });
        
        select.disabled = false;
      }
      
      async loadWorkflow(workflowId) {
        if (!workflowId) {
          this.currentWorkflow = null;
          this.elements.preview.removeAttribute('workflow');
          this.elements.editLink.href = '#';
          this.elements.saveBtn.disabled = true;
          return;
        }
        
        this.showLoading(true, 'Loading workflow...');
        
        try {
          const workflow = await this.makeApiCall(`/api/v1/workflows/${workflowId}`);
          this.currentWorkflow = workflow;
          
          // Update preview
          this.elements.preview.setAttribute('workflow', JSON.stringify(workflow));
          
          // Update edit link (remove proxy from URL if present)
          const cleanUrl = this.n8nUrl.includes('corsproxy.io') 
            ? decodeURIComponent(this.n8nUrl.split('corsproxy.io/?')[1]) 
            : this.n8nUrl;
          this.elements.editLink.href = `${cleanUrl}/workflow/${workflowId}`;
          
          // Enable save button and mark as saved
          this.elements.saveBtn.disabled = false;
          this.markAsSaved();
          
          // Set up change detection
          this.setupChangeDetection();
          
          this.showStatus(`‚úÖ Loaded workflow: ${workflow.name}`, 'success');
          
        } catch (error) {
          console.error('Failed to load workflow:', error);
          this.showStatus(`‚ùå Failed to load workflow: ${error.message}`, 'error');
        } finally {
          this.showLoading(false);
        }
      }
      
      async saveWorkflow() {
        if (!this.currentWorkflow) {
          this.showStatus('‚ö†Ô∏è No workflow selected to save', 'warning');
          return;
        }
        
        if (!this.isConnected) {
          this.showStatus('‚ö†Ô∏è Not connected to n8n instance. Please connect first.', 'warning');
          return;
        }
        
        this.showLoading(true, 'Saving workflow...');
        this.elements.saveBtn.disabled = true;
        
        try {
          // Get current workflow data from the preview component (legacy format)
          const legacyFormatData = JSON.parse(this.elements.preview.getAttribute('workflow') || '{}');
          
          // Create clean workflow data for API save (remove read-only properties)
          const workflowToSave = {
            name: this.currentWorkflow.name,
            // Don't include 'active' - it's read-only in the API
            nodes: legacyFormatData.nodes || [],
            connections: legacyFormatData.connections || {},
            settings: this.currentWorkflow.settings || {}
          };
          
          // Only include optional fields if they exist
          if (legacyFormatData.pinData && Object.keys(legacyFormatData.pinData).length > 0) {
            workflowToSave.pinData = legacyFormatData.pinData;
          }
          
          if (this.currentWorkflow.staticData !== null && this.currentWorkflow.staticData !== undefined) {
            workflowToSave.staticData = this.currentWorkflow.staticData;
          }
          
          // Don't include these read-only properties that cause 400 errors:
          // - id, createdAt, updatedAt, shared, tags, versionId, triggerCount
          
          console.log('Clean workflow for API save:', workflowToSave);
          
          // Case 1: Workflow has an ID - update existing workflow
          if (this.currentWorkflow.id) {
            await this.makeApiCall(`/api/v1/workflows/${this.currentWorkflow.id}`, {
              method: 'PUT',
              body: JSON.stringify(workflowToSave)
            });
            this.showStatus('üíæ Workflow updated successfully!', 'success');
          }
          
          // Case 2: No ID - try to find by name or create new workflow
          else {
            const existingWorkflow = this.workflows.find(w => w.name === workflowToSave.name);
            
            if (existingWorkflow) {
              // Update existing workflow with same name
              const confirm = window.confirm(`A workflow named "${workflowToSave.name}" already exists. Update it?`);
              if (confirm) {
                await this.makeApiCall(`/api/v1/workflows/${existingWorkflow.id}`, {
                  method: 'PUT',
                  body: JSON.stringify({...workflowToSave, id: existingWorkflow.id})
                });
                this.currentWorkflow.id = existingWorkflow.id;
                this.showStatus('üíæ Existing workflow updated successfully!', 'success');
              } else {
                return; // User cancelled
              }
            } else {
              // Create new workflow
              const newWorkflow = await this.makeApiCall('/api/v1/workflows', {
                method: 'POST',
                body: JSON.stringify(workflowToSave)
              });
              this.currentWorkflow.id = newWorkflow.id;
              this.showStatus('üíæ New workflow created successfully!', 'success');
            }
          }
          
          // Update current workflow to reflect saved state
          this.currentWorkflow = workflowToSave;
          this.markAsSaved();
          
          // Update edit link if we have an ID now
          if (this.currentWorkflow.id) {
            // Clean the URL for the edit link (remove proxy if present)
            const cleanUrl = this.n8nUrl.includes('corsproxy.io') 
              ? decodeURIComponent(this.n8nUrl.split('corsproxy.io/?')[1]) 
              : this.n8nUrl;
            this.elements.editLink.href = `${cleanUrl}/workflow/${this.currentWorkflow.id}`;
          }
          
        } catch (error) {
          console.error('Failed to save workflow:', error);
          this.showStatus(`‚ùå Failed to save workflow: ${error.message}`, 'error');
        } finally {
          this.showLoading(false);
          this.elements.saveBtn.disabled = false;
        }
      }
      
      setupChangeDetection() {
        // Monitor workflow changes using MutationObserver
        if (this.workflowObserver) {
          this.workflowObserver.disconnect();
        }
        
        this.workflowObserver = new MutationObserver((mutations) => {
          // Check if workflow attribute changed
          mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'workflow') {
              this.markAsChanged();
            }
          });
        });
        
        // Start observing the workflow preview component
        this.workflowObserver.observe(this.elements.preview, {
          attributes: true,
          attributeFilter: ['workflow']
        });
        
        // Also set up periodic change detection as a fallback
        if (this.changeDetectionInterval) {
          clearInterval(this.changeDetectionInterval);
        }
        
        let lastWorkflowHash = this.hashWorkflow(this.currentWorkflow);
        this.changeDetectionInterval = setInterval(() => {
          if (this.currentWorkflow) {
            const currentData = this.elements.preview.getAttribute('workflow');
            if (currentData) {
              const currentHash = this.hashWorkflow(JSON.parse(currentData));
              if (currentHash !== lastWorkflowHash) {
                this.markAsChanged();
                lastWorkflowHash = currentHash;
              }
            }
          }
        }, 1000);
      }
      
      hashWorkflow(workflow) {
        // Simple hash function for workflow comparison
        return JSON.stringify(workflow).split('').reduce((hash, char) => {
          hash = ((hash << 5) - hash) + char.charCodeAt(0);
          return hash & hash; // Convert to 32-bit integer
        }, 0);
      }
      
      cleanup() {
        if (this.workflowObserver) {
          this.workflowObserver.disconnect();
        }
        if (this.changeDetectionInterval) {
          clearInterval(this.changeDetectionInterval);
        }
      }
      
      async autoSave() {
        if (!this.autoSaveEnabled || !this.currentWorkflow || !this.isConnected || !this.hasUnsavedChanges) {
          return;
        }
        
        try {
          // Get current workflow data from the preview component (legacy format)
          const currentData = this.elements.preview.getAttribute('workflow');
          if (!currentData) return;
          
          const legacyFormatData = JSON.parse(currentData);
          
          // Create clean workflow data for API save (same as manual save)
          const workflowToSave = {
            name: this.currentWorkflow.name,
            // Don't include 'active' - it's read-only in the API
            nodes: legacyFormatData.nodes || [],
            connections: legacyFormatData.connections || {},
            settings: this.currentWorkflow.settings || {}
          };
          
          // Only include optional fields if they exist
          if (legacyFormatData.pinData && Object.keys(legacyFormatData.pinData).length > 0) {
            workflowToSave.pinData = legacyFormatData.pinData;
          }
          
          if (this.currentWorkflow.staticData !== null && this.currentWorkflow.staticData !== undefined) {
            workflowToSave.staticData = this.currentWorkflow.staticData;
          }
          
          // Only save if there are actual changes to nodes/connections
          const currentNodes = JSON.stringify(this.currentWorkflow.nodes || []);
          const currentConnections = JSON.stringify(this.currentWorkflow.connections || {});
          const newNodes = JSON.stringify(legacyFormatData.nodes || []);
          const newConnections = JSON.stringify(legacyFormatData.connections || {});
          
          const hasChanges = currentNodes !== newNodes || currentConnections !== newConnections;
          if (!hasChanges) {
            this.hasUnsavedChanges = false;
            return;
          }
          
          // Show saving indicator
          this.showLoading(true, 'Auto-saving...');
          
          // Update the workflow via API
          await this.makeApiCall(`/api/v1/workflows/${this.currentWorkflow.id}`, {
            method: 'PUT',
            body: JSON.stringify(workflowToSave)
          });
          
          // Update current workflow to reflect saved state
          this.currentWorkflow = workflowToSave;
          this.hasUnsavedChanges = false;
          
          this.showStatus('üíæ Auto-saved successfully', 'success');
          
        } catch (error) {
          console.error('Auto-save failed:', error);
          this.showStatus('‚ö†Ô∏è Auto-save failed - changes not saved', 'warning');
        } finally {
          this.showLoading(false);
        }
      }
      
      markAsChanged() {
        this.hasUnsavedChanges = true;
        // Update save button to show there are unsaved changes
        if (this.elements.saveBtn && !this.elements.saveBtn.disabled) {
          this.elements.saveBtn.innerHTML = '<span>üíæ</span> Save Changes*';
          this.elements.saveBtn.style.backgroundColor = '#f59e0b'; // Warning color
        }
      }
      
      markAsSaved() {
        this.hasUnsavedChanges = false;
        if (this.elements.saveBtn) {
          this.elements.saveBtn.innerHTML = '<span>üíæ</span> Save Changes';
          this.elements.saveBtn.style.backgroundColor = ''; // Reset to default
        }
      }
      
      async refreshWorkflows() {
        if (!this.isConnected) {
          this.showStatus('‚ö†Ô∏è Not connected to n8n instance', 'warning');
          return;
        }
        
        this.elements.refreshBtn.disabled = true;
        await this.loadWorkflows();
        this.elements.refreshBtn.disabled = false;
      }
      
      async makeApiCall(endpoint, options = {}) {
        const url = `${this.n8nUrl}${endpoint}`;
        const method = options.method || 'GET';
        
        // Build minimal headers to avoid CORS preflight
        const headers = {
          'X-N8N-API-KEY': this.apiKey
        };
        
        // Only add Content-Type for requests with body
        if (method !== 'GET' && method !== 'HEAD' && options.body) {
          headers['Content-Type'] = 'application/json';
        }
        
        // Add any custom headers
        if (options.headers) {
          Object.assign(headers, options.headers);
        }
        
        const fetchOptions = {
          method,
          headers,
          ...options
        };
        
        try {
          const response = await fetch(url, fetchOptions);
          
          if (!response.ok) {
            let errorText;
            try {
              const errorJson = await response.json();
              console.log('API Error Response:', errorJson);
              errorText = errorJson.message || JSON.stringify(errorJson, null, 2);
            } catch {
              errorText = await response.text();
            }
            
            // Provide specific guidance for common errors
            if (response.status === 400) {
              console.error('400 Error Details:', errorText);
              if (errorText.includes('additional properties')) {
                errorText = 'Invalid workflow data format. Some properties are not allowed in the API request.';
              }
            }
            
            throw new Error(`API call failed (${response.status}): ${errorText}`);
          }
          
          // Handle empty responses
          const contentType = response.headers.get('content-type');
          if (contentType && contentType.includes('application/json')) {
            return await response.json();
          } else {
            return {};
          }
        } catch (error) {
          // Provide better error messages for common issues
          if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
            throw new Error('Network error: Check CORS configuration or internet connection');
          }
          throw error;
        }
      }
      
      enableWorkflowControls() {
        this.elements.workflowSelect.disabled = false;
        this.elements.refreshBtn.disabled = false;
      }
      
      showLoading(show, message = 'Loading...') {
        const loading = this.elements.loading;
        if (show) {
          loading.classList.add('show');
          loading.querySelector('span').textContent = message;
        } else {
          loading.classList.remove('show');
        }
      }
      
      showStatus(message, type = 'success') {
        const status = this.elements.statusMsg;
        status.textContent = message;
        status.className = `status ${type}`;
        status.style.display = 'block';
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
          status.style.display = 'none';
        }, 5000);
      }
      
      toggleFullscreen() {
        const el = document.documentElement;
        if (el.requestFullscreen && !document.fullscreenElement) {
          el.requestFullscreen();
        } else if (document.exitFullscreen && document.fullscreenElement) {
          document.exitFullscreen();
        }
      }
      
      initializePreviewSizing() {
        const sizePreview = () => {
          const preview = this.elements.preview;
      const header = document.querySelector('header');
          const configPanel = document.querySelector('.config-panel');
          const workflowSelector = document.querySelector('.workflow-selector');
      const footer = document.querySelector('footer');
          const pad = 16; // --pad value
          
          const used = header.offsetHeight + configPanel.offsetHeight + 
                      workflowSelector.offsetHeight + footer.offsetHeight + (pad * 4);
          const availableHeight = Math.max(500, window.innerHeight - used);
          
          preview.style.height = availableHeight + 'px';
        };
        
    window.addEventListener('load', sizePreview);
    window.addEventListener('resize', sizePreview);

        // Initial size after a short delay to ensure DOM is ready
        setTimeout(sizePreview, 100);
      }
    }
    
    // Initialize the editor when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      window.n8nEditor = new N8nDynamicEditor();
    });
    
    // Fallback for older browsers
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        if (!window.n8nEditor) {
          window.n8nEditor = new N8nDynamicEditor();
        }
      });
    } else {
      window.n8nEditor = new N8nDynamicEditor();
    }
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (window.n8nEditor) {
        window.n8nEditor.cleanup();
      }
    });
    
    // Warn about unsaved changes
    window.addEventListener('beforeunload', (e) => {
      if (window.n8nEditor && window.n8nEditor.hasUnsavedChanges) {
        e.preventDefault();
        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
        return e.returnValue;
      }
    });
  </script>
</body>
</html>
