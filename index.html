<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>n8n Dynamic Workflow Editor</title>

  <!-- Required scripts for the n8n preview component -->
  <script src="https://cdn.jsdelivr.net/npm/@webcomponents/webcomponentsjs@2/webcomponents-loader.js"></script>
  <script src="https://www.unpkg.com/lit@2/polyfill-support.js"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/@n8n_io/n8n-demo-component/n8n-demo.bundled.js"></script>
  
  <!-- Optional configuration file -->
  <script src="config.js" onerror="console.log('No config.js found, using defaults')"></script>

  <style>
    :root { --pad: 16px; --primary: #ff6d5a; --primary-hover: #e55a47; --secondary: #4f46e5; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
    body {
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      color: #e2e8f0;
      display: grid; 
      grid-template-rows: 1fr auto;
      gap: var(--pad);
    }
    
    .container { max-width: 100%; margin: 0 auto; padding: 0 var(--pad); }
    

    

    
    /* Buttons */
    .btn {
      padding: 10px 16px; border-radius: 8px; border: none; cursor: pointer;
      font-weight: 500; text-decoration: none; display: inline-flex; align-items: center; gap: 8px;
      transition: all 0.2s ease; font-size: 14px; min-width: auto;
    }
    .btn-primary { background: var(--primary); color: white; }
    .btn-primary:hover { background: var(--primary-hover); transform: translateY(-1px); }
    .btn-secondary { background: var(--secondary); color: white; }
    .btn-secondary:hover { background: #4338ca; transform: translateY(-1px); }
    .btn-outline { background: transparent; color: #e2e8f0; border: 1px solid #374151; }
    .btn-outline:hover { background: #374151; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }
    
    /* Main content */
    main { min-height: 0; padding: 0 var(--pad); position: relative; }
    
    /* Workflow selector styles removed - no longer needed */
    
    /* Workflow viewer */
    .workflow-container { 
      position: relative; border-radius: 14px; overflow: hidden; 
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      min-height: 820px; /* Account for component height + edit button */
    }
    .preview-header {
      background: rgba(239, 68, 68, 0.1); border-bottom: 1px solid rgba(239, 68, 68, 0.2);
      padding: 12px 16px; display: flex; align-items: center; justify-content: space-between;
      color: #ef4444; font-size: 14px;
    }
    .preview-status { font-weight: 500; }
    .preview-header > div:last-child { display: flex; gap: 8px; }
    .btn-primary { 
      background: #3b82f6; border: 1px solid #2563eb; color: white; 
      transition: background-color 0.2s ease;
    }
    .btn-primary:hover { background: #2563eb; }
    .btn-primary:disabled { 
      background: #6b7280; border-color: #6b7280; cursor: not-allowed; 
      opacity: 0.6; 
    }
    n8n-demo {
      width: 100%; height: 100%; display: block; 
      background: #0b1220; border: 1px solid #334155; min-height: 800px;
    }
    
    /* Status and loading */
    .status { 
      padding: 8px 12px; background: rgba(34, 197, 94, 0.1); color: #22c55e;
      border: 1px solid rgba(34, 197, 94, 0.2); border-radius: 6px; font-size: 12px; font-weight: 500;
    }
    .status.error { background: rgba(239, 68, 68, 0.1); color: #ef4444; border-color: rgba(239, 68, 68, 0.2); }
    .status.warning { background: rgba(245, 158, 11, 0.1); color: #f59e0b; border-color: rgba(245, 158, 11, 0.2); }
    
    /* Footer */
    footer { padding: var(--pad); font-size: 12px; color: #64748b; text-align: center; }
    footer a { color: var(--primary); text-decoration: none; }
    footer a:hover { text-decoration: underline; }
    
    /* Responsive */
    @media (max-width: 768px) {
      :root { --pad: 12px; }
      /* Selector grid styles removed - no longer needed */
    }
  </style>
</head>
<body>




  <main>
    <!-- Status Message -->
      <div id="statusMsg" class="status" style="display: none; margin-top: 12px;"></div>

        <!-- Workflow Viewer -->
    <div class="workflow-container">
      <!-- Workflow Actions -->
      <div style="padding: 16px; background: rgba(17, 24, 39, 0.9); border-bottom: 1px solid #374151; text-align: center;">
        <div style="display: flex; gap: 12px; justify-content: center; align-items: center;">
          <button id="refreshPreviewBtn" class="btn btn-outline" style="font-size: 14px; padding: 12px 20px;" title="Refresh the preview to see the latest changes after editing the workflow">
            <span>üîÑ</span> Refresh Preview
          </button>
          <button id="editWorkflowBtn" class="btn btn-primary" disabled style="font-size: 14px; padding: 12px 24px;" title="Open the n8n workflow editor in a new tab for editing">
            <span>‚úèÔ∏è</span> Edit Workflow
          </button>
        </div>

      </div>
      
      <div class="preview-header" style="display: none;">
        <div class="preview-status">‚ö†Ô∏è Preview failed to load</div>
      </div>
      <!-- Preview Component -->
      <n8n-demo id="preview" frame="false" style="display: block;"></n8n-demo>
    </div>
  </main>

  <footer>
    <p>
      üéØ <strong>Dynamic n8n Integration:</strong> Connect to your n8n instance to load, view, and save workflows directly.
      <br/>
      üí° Perfect for embedding in <a href="https://notion.so" target="_blank">Notion</a> or any other platform.
    </p>
  </footer>

  <script>
    // ==========================================
    // n8n Dynamic Workflow Editor
    // ==========================================
    
    class N8nDynamicEditor {
      constructor() {
        // Load configuration (optional)
        this.config = window.N8N_CONFIG || {};
        
        // Try direct connection first, then fall back to CORS proxy
        this.baseN8nUrl = 'https://n8n-test.teljoy.io';
        this.corsProxyUrl = 'https://corsproxy.io/?https://n8n-test.teljoy.io';
        this.n8nUrl = this.baseN8nUrl; // Start with direct connection
        // API key - injected during GitHub Pages build
        this.apiKey = '__N8N_API_KEY__';
        console.log('‚úÖ Using API key from GitHub Secrets deployment');
        this.workflows = [];
        this.currentWorkflow = null;
        this.isConnected = false;
        
        this.initializeElements();
        this.bindEvents();
        this.parseUrlParameters();
        this.applyBranding();
        this.initializePreviewSizing();
        
        // Workflow action buttons start disabled until a workflow is loaded
        this.elements.editWorkflowBtn.disabled = true;
        this.elements.refreshPreviewBtn.disabled = false; // Always enabled for refresh & reload
        
        // Auto-connect with hardcoded API key after a short delay
        setTimeout(() => {
          this.connect();
        }, 300);
      }
      
      initializeElements() {
        this.elements = {
          statusMsg: document.getElementById('statusMsg'),
          preview: document.getElementById('preview'),
          editWorkflowBtn: document.getElementById('editWorkflowBtn'),
          refreshPreviewBtn: document.getElementById('refreshPreviewBtn'),
          previewHeader: document.querySelector('.preview-header')
        };
      }
      
      bindEvents() {
        this.elements.refreshPreviewBtn.addEventListener('click', () => this.refreshAndReload());
        
        // Edit workflow button
        this.elements.editWorkflowBtn.addEventListener('click', () => this.openWorkflowEditor());
      }
      
      openWorkflowEditor() {
        if (!this.currentWorkflow || !this.isConnected) {
          this.showStatus('‚ùå No workflow selected or not connected to n8n', 'error');
          return;
        }
        
        console.log('‚úèÔ∏è Opening workflow editor for:', this.currentWorkflow.name);
        
        // Get clean n8n URL (without proxy)
        const cleanUrl = this.n8nUrl.includes('corsproxy.io') 
          ? decodeURIComponent(this.n8nUrl.split('corsproxy.io/?')[1]) 
          : this.n8nUrl;
          
        // Build the editor URL
        const editorUrl = `${cleanUrl}/workflow/${this.currentWorkflow.id}`;
        
        // Open in new tab
        const newTab = window.open(editorUrl, '_blank');
        
        if (newTab) {
          this.showStatus(`‚úèÔ∏è Opened "${this.currentWorkflow.name}" in new tab`, 'success');
          console.log('‚úÖ Workflow editor opened successfully in new tab');
        } else {
          this.showStatus('‚ùå Failed to open editor. Check if popups are blocked.', 'error');
          console.log('‚ùå Editor failed to open in new tab');
        }

        /* COMMENTED OUT: Previous popup implementation
        // Open in popup window with optimal settings
        const popup = window.open(
          editorUrl,
          'n8nEditor',
          'width=1400,height=900,scrollbars=yes,resizable=yes,status=no,menubar=no,toolbar=no'
        );
        
        if (popup) {
          this.showStatus(`‚úèÔ∏è Opened "${this.currentWorkflow.name}" in editor`, 'success');
          console.log('‚úÖ Workflow editor opened successfully');
          
          // Focus the popup window
          popup.focus();
          
          // Optional: Listen for popup close and refresh workflow
          const checkClosed = setInterval(() => {
            if (popup.closed) {
              clearInterval(checkClosed);
              console.log('üìù Editor closed, refreshing workflow...');
              this.showStatus('üìù Editor closed. Refreshing workflow data...', 'info');
              
              // Refresh the current workflow from API
              if (this.currentWorkflow && this.isConnected) {
                setTimeout(() => {
                  this.loadWorkflow(this.currentWorkflow.id);
                }, 1000); // Small delay to allow n8n to save changes
              }
            }
          }, 1000);
          
        } else {
          this.showStatus('‚ùå Failed to open editor. Check if popups are blocked.', 'error');
          console.log('‚ùå Editor popup blocked or failed to open');
        }
        */
      }
      

      
      forcePreviewRefresh() {
        console.log('üí• ===== FORCING COMPLETE PREVIEW REFRESH =====');
        
        // Step 1: Show loading state
        this.hidePreviewError();
        this.showStatus('üîÑ Refreshing preview...', 'info');
        
        // Step 2: Completely destroy and recreate the component
        if (!this.elements.preview) {
          console.warn('‚ö†Ô∏è Preview element not found, reinitializing...');
          this.elements.preview = document.getElementById('preview');
        }
        
        const container = this.elements.preview?.parentNode;
        const oldElement = this.elements.preview;
        
        if (!container || !oldElement) {
          console.warn('‚ö†Ô∏è Container or preview element not found, using alternative refresh method');
          // Alternative approach: just clear and reset the workflow attribute
          if (oldElement) {
            oldElement.removeAttribute('workflow');
            setTimeout(() => {
              // Re-apply workflow data after a brief delay
              if (this.currentWorkflow) {
                oldElement.setAttribute('workflow', JSON.stringify(this.currentWorkflow));
              }
            }, 100);
          }
          return;
        }
        
        // Remove old element completely
        container.removeChild(oldElement);
        
        // Step 3: Create brand new component
        const newElement = document.createElement('n8n-demo');
        newElement.id = 'preview';
        newElement.setAttribute('frame', 'false');
        newElement.style.display = 'block'; // Ensure it's visible in preview mode
        
        // Step 4: Add it back to the DOM
        container.appendChild(newElement);
        
        // Step 5: Update our reference
        this.elements.preview = newElement;
        
        // Step 6: Re-bind events for auto-save
        this.bindPreviewEvents();
        
        console.log('‚úÖ Preview component completely refreshed and ready');
      }
      
      checkComponentState(checkName) {
        const previewElement = this.elements.preview;
        const hasWorkflowAttribute = previewElement.hasAttribute('workflow');
        const workflowValue = previewElement.getAttribute('workflow');
        
        console.log(`--- ${checkName} ---`);
        console.log('Component basic state:');
        console.log('  - Has workflow attribute:', hasWorkflowAttribute);
        console.log('  - Workflow attribute length:', workflowValue ? workflowValue.length : 0);
        console.log('  - Element innerHTML length:', previewElement.innerHTML.length);
        console.log('  - Shadow root exists:', !!previewElement.shadowRoot);
        
        let shadowContent = '';
        let hasCanvas = false;
        let hasErrors = false;
        let errorMessages = [];
        
        if (previewElement.shadowRoot) {
          shadowContent = previewElement.shadowRoot.innerHTML;
          console.log('  - Shadow root innerHTML length:', shadowContent.length);
          
          // Check for canvas or svg elements (signs of successful render)
          const canvasElements = previewElement.shadowRoot.querySelectorAll('canvas, svg, .workflow-canvas');
          hasCanvas = canvasElements.length > 0;
          console.log('  - Has canvas/svg elements:', hasCanvas, `(found ${canvasElements.length})`);
          
          // Check for any error indicators
          const errorSelectors = [
            '[data-test-id*="error"]',
            '.error',
            '[class*="error"]',
            '[class*="Error"]',
            '.n8n-toast--error',
            '.message-error',
            '.workflow-error'
          ];
          
          errorSelectors.forEach(selector => {
            const elements = previewElement.shadowRoot.querySelectorAll(selector);
            if (elements.length > 0) {
              hasErrors = true;
              elements.forEach((el, i) => {
                const msg = el.textContent || el.innerHTML || `[${selector} element ${i}]`;
                errorMessages.push(msg.trim().substring(0, 200));
                console.log(`  ‚ùå Error found (${selector}):`, msg.trim().substring(0, 100));
              });
            }
          });
          
          // Look for "Could not load" message specifically
          if (shadowContent.includes('Could not load')) {
            hasErrors = true;
            errorMessages.push('Found "Could not load" message in shadow content');
            console.log('  ‚ùå Found "Could not load" message in shadow content');
          }
        }
        
        // Overall success assessment
        const isSuccess = hasWorkflowAttribute && 
                         shadowContent.length > 500 && 
                         (hasCanvas || previewElement.innerHTML.length > 100) && 
                         !hasErrors;
        
        console.log('Component assessment:');
        console.log('  - Overall success:', isSuccess);
        console.log('  - Has content:', shadowContent.length > 500);
        console.log('  - Has visual elements:', hasCanvas);
        console.log('  - Has errors:', hasErrors);
        
        if (hasErrors && errorMessages.length > 0) {
          console.log('  - Error messages:', errorMessages);
        }
        
        // Try to get component's internal state if possible
        if (previewElement.workflow) {
          console.log('  - Component internal workflow exists');
        }
        
        return isSuccess;
      }
      
      // Hard reset component method removed - no longer needed
      
      bindPreviewEvents() {
        // Preview events binding removed - workflows are view-only
      }
      
      async refreshAndReload() {
        console.log('üîÑ Refresh & Reload triggered');
        this.elements.refreshPreviewBtn.disabled = true;
        
        try {
          // First, test/reconnect to ensure we have a valid connection
          console.log('üîó Re-establishing connection...');
          await this.testConnection();
          this.isConnected = true;
          console.log('‚úÖ Connection verified');
          
          // Then reload the current workflow or from URL parameter
          const workflowId = this.urlParams.workflowId || (this.currentWorkflow && this.currentWorkflow.id);
          if (workflowId) {
            console.log(`üì° Fetching latest version of workflow: ${workflowId}`);
            
            const updatedWorkflow = await this.makeApiCall(`/api/v1/workflows/${workflowId}`);
            this.currentWorkflow = updatedWorkflow;
            
            // Force a complete preview refresh with new data
            this.forcePreviewRefresh();
            
            // Update preview with latest workflow data
            this.elements.preview.setAttribute('workflow', JSON.stringify(updatedWorkflow));
            
            // Enable edit button
            this.elements.editWorkflowBtn.disabled = false;
            
            this.showStatus(`üîÑ Refreshed workflow: ${updatedWorkflow.name}`, 'success');
            console.log('‚úÖ Workflow refreshed successfully');
            } else {
            this.showStatus('‚ö†Ô∏è No workflow ID found in URL or current session', 'warning');
          }
          
        } catch (error) {
          console.error('‚ùå Refresh & Reload failed:', error);
          this.showStatus(`‚ùå Failed to refresh: ${error.message}`, 'error');
          this.isConnected = false;
        } finally {
          this.elements.refreshPreviewBtn.disabled = false;
        }
      }
      
      // Legacy refresh method removed - use refreshCurrentWorkflow instead
      
      showPreviewError() {
        if (this.elements.previewHeader) {
          this.elements.previewHeader.style.display = 'flex';
        }
      }
      
      hidePreviewError() {
        if (this.elements.previewHeader) {
          this.elements.previewHeader.style.display = 'none';
        }
      }
      
      parseUrlParameters() {
        const urlParams = new URLSearchParams(window.location.search);
        this.urlParams = {
          // Direct workflow JSON
          workflow: urlParams.get('workflow'),
          // Workflow ID + n8n URL to load from API  
          workflowId: urlParams.get('workflowId'),
          n8nUrl: urlParams.get('n8nUrl'),
          // External workflow JSON URL
          workflowUrl: urlParams.get('workflowUrl'),
          // API key (not recommended for security, but supported)
          apiKey: urlParams.get('apiKey')
        };
      }
      
      async handleUrlWorkflow() {
        const params = this.urlParams;
        
        // Case 1: Direct workflow JSON in URL
        if (params.workflow) {
          try {
            const workflowData = JSON.parse(decodeURIComponent(params.workflow));
            this.loadWorkflowFromData(workflowData, 'URL Parameter');
            this.showStatus('‚úÖ Loaded workflow from URL parameter', 'success');
          } catch (error) {
            this.showStatus('‚ùå Invalid workflow JSON in URL parameter', 'error');
          }
        }
        
        // Case 2: Load from external JSON URL
        else if (params.workflowUrl) {
          try {
            const response = await fetch(params.workflowUrl);
            const workflowData = await response.json();
            this.loadWorkflowFromData(workflowData, 'External URL');
            this.showStatus('‚úÖ Loaded workflow from external URL', 'success');
          } catch (error) {
            this.showStatus(`‚ùå Failed to load workflow from URL: ${error.message}`, 'error');
          }
        }
        
        // Case 3: Load from n8n API using workflow ID
        else if (params.workflowId && params.n8nUrl) {
          this.n8nUrl = params.n8nUrl;
          this.elements.n8nUrl.value = params.n8nUrl;
          
          // Prompt for API key and then load workflow
          await this.promptForApiKey();
          if (this.apiKey) {
            await this.loadWorkflowFromApi(params.workflowId);
          }
        }
      }
      
      loadWorkflowFromData(workflowData, source) {
        console.log('üîÑ ===== NEW WORKFLOW LOADING STARTED =====');
        console.log('üìç Source:', source);
        console.log('üìä Workflow Name:', workflowData?.name || 'Unnamed');
        console.log('üÜî Workflow ID:', workflowData?.id || 'No ID');
        
        this.currentWorkflow = workflowData;
        
        // Hide error initially while loading
        this.hidePreviewError();
        
        console.log('=== DETAILED WORKFLOW LOADING DEBUG ===');
        console.log('1. Source:', source);
        console.log('2. Raw API data keys:', Object.keys(workflowData || {}));
        console.log('3. Raw API data:', workflowData);
        
        // Compare with working legacy format structure
        console.log('4. API vs Legacy comparison:');
        console.log('   - API nodes count:', (workflowData.nodes || []).length);
        console.log('   - API connections count:', Object.keys(workflowData.connections || {}).length);
        console.log('   - API has pinData?', !!workflowData.pinData);
        console.log('   - API has meta?', !!workflowData.meta);
        console.log('   - API extra properties:', Object.keys(workflowData || {}).filter(k => 
          !['nodes', 'connections', 'pinData', 'meta'].includes(k)));
        
        // Create format that EXACTLY matches the working legacy workflow.json
        const legacyFormatWorkflow = {
          nodes: workflowData.nodes || [],
          connections: workflowData.connections || {}
        };
        
        // Add pinData only if it exists and has content (like legacy)
        if (workflowData.pinData && Object.keys(workflowData.pinData).length > 0) {
          legacyFormatWorkflow.pinData = workflowData.pinData;
          console.log('5. Added pinData with keys:', Object.keys(workflowData.pinData));
        } else {
          console.log('5. No pinData to add');
        }
        
        // Add meta only if it has instanceId (like legacy)
        if (workflowData.meta && workflowData.meta.instanceId) {
          legacyFormatWorkflow.meta = {
            instanceId: workflowData.meta.instanceId
          };
          console.log('6. Added meta with instanceId:', workflowData.meta.instanceId);
        } else {
          console.log('6. No meta.instanceId to add');
        }
        
        // Validate critical structure
        if (!Array.isArray(legacyFormatWorkflow.nodes)) {
          console.log('‚ö†Ô∏è FIXING: nodes is not an array!');
          legacyFormatWorkflow.nodes = [];
        }
        
        if (!legacyFormatWorkflow.connections || typeof legacyFormatWorkflow.connections !== 'object') {
          console.log('‚ö†Ô∏è FIXING: connections is not an object!');
          legacyFormatWorkflow.connections = {};
        }
        
        console.log('7. Final cleaned workflow keys:', Object.keys(legacyFormatWorkflow));
        console.log('8. Final cleaned workflow:', legacyFormatWorkflow);
        
        // Load workflow in preview component
        console.log('9. Setting workflow data on preview component...');
          this.elements.preview.setAttribute('workflow', JSON.stringify(legacyFormatWorkflow));
          console.log('10. Workflow data set');
        
        // Enable edit button
        if (this.isConnected && workflowData.id) {
          this.elements.editWorkflowBtn.disabled = false;
          console.log('‚úÖ Edit workflow button enabled');
        }
          
          // Check if loading was successful
          setTimeout(() => {
          console.log('=== CHECKING PREVIEW COMPONENT LOAD (1s) ===');
          const success = this.checkComponentState('Preview component check');
            
            if (success) {
            console.log('‚úÖ Preview component loaded successfully!');
              this.hidePreviewError();
            this.showStatus(`‚úÖ Workflow loaded: "${workflowData.name || 'Unnamed'}"`, 'success');
            } else {
            console.log('‚ùå Preview component failed to load');
              this.showPreviewError();
              this.showStatus(`‚ùå Preview failed to load: "${workflowData.name || 'Unnamed'}"`, 'error');
            }
          }, 1000);
          
        // Save functionality removed - workflows are view-only
        
        // Update status
        const workflowName = workflowData.name || workflowData.id || 'Unnamed';
        this.showStatus(`‚úÖ Loaded workflow "${workflowName}" from ${source}`, 'success');
      }
      
      // Legacy fallback test method removed - no longer needed
      
      async loadWorkflowFromApi(workflowId) {
        try {
          let workflow;
          try {
            // Try v1 API first
            workflow = await this.makeApiCall(`/api/v1/workflows/${workflowId}`);
          } catch (error) {
            // Fall back to older API endpoint
            workflow = await this.makeApiCall(`/rest/workflows/${workflowId}`);
          }
          
          this.isConnected = true;
          this.loadWorkflowFromData(workflow, 'n8n API');

          
        } catch (error) {
          this.showStatus(`‚ùå Failed to load workflow from API: ${error.message}`, 'error');
        }
      }
      
      loadFromLocalStorage() {
        // Don't auto-load API keys - always prompt for security
        // URL is hardcoded, so no need to load from localStorage
      }
      
      applyBranding() {
        const branding = this.config.branding || {};
        
        // Update title if configured
        if (branding.title) {
          document.title = branding.title;
          const titleElement = document.querySelector('.title');
          if (titleElement) {
            titleElement.textContent = `üöÄ ${branding.title}`;
          }
        }
        
        // Update primary color if configured
        if (branding.primaryColor) {
          document.documentElement.style.setProperty('--primary', branding.primaryColor);
        }
        
        // Hide powered by message if configured
        if (branding.showPoweredBy === false) {
          const footer = document.querySelector('footer p');
          if (footer) {
          footer.innerHTML = 'üí° Perfect for embedding in <a href="https://notion.so" target="_blank">Notion</a> or any other platform.';
          }
        }
      }
      
      saveToLocalStorage() {
        // Don't save API keys for security - they're always prompted for
        // URL is hardcoded, so no need to save
      }
      
      async connect() {
        console.log('üîó Starting connection...');
        console.log('üìç n8n URL:', this.n8nUrl);
        console.log('üîë API Key (first 20 chars):', this.apiKey.substring(0, 20) + '...');
        console.log('üîë API Key length:', this.apiKey.length);
        console.log('üîë API Key starts with "ey":', this.apiKey.startsWith('ey'));
        
        // Validate API key format (JWT should have 3 parts separated by dots)
        const keyParts = this.apiKey.split('.');
        console.log('üîë API Key parts:', keyParts.length, '(should be 3 for JWT)');
        if (keyParts.length !== 3) {
          console.warn('‚ö†Ô∏è API Key does not appear to be a valid JWT token');
        }
        
        try {
          // Test connection with hardcoded API key - use the same robust method as refresh
          console.log('üß™ Testing connection...');
          
          // Try connection with multiple attempts if needed
          let connectionSuccessful = false;
          let attemptCount = 0;
          const maxAttempts = 2;
          
          while (!connectionSuccessful && attemptCount < maxAttempts) {
            attemptCount++;
            console.log(`üîÑ Connection attempt ${attemptCount}/${maxAttempts}`);
            
            try {
          await this.testConnection();
              connectionSuccessful = true;
          this.isConnected = true;
              console.log('‚úÖ Connection test successful');
            } catch (error) {
              console.warn(`‚ö†Ô∏è Connection attempt ${attemptCount} failed:`, error.message);
              if (attemptCount < maxAttempts) {
                console.log('üîÑ Retrying connection in 1 second...');
                await new Promise(resolve => setTimeout(resolve, 1000));
              } else {
                throw error; // Re-throw on final attempt
              }
            }
          }
          
          this.showStatus('‚úÖ Connected successfully!', 'success');
          
          // Auto-load workflow from URL parameter if provided
          if (this.urlParams.workflowId) {
            console.log('üîÑ Loading workflow from URL parameter:', this.urlParams.workflowId);
            await this.loadWorkflow(this.urlParams.workflowId);
          } else {
            this.showStatus('‚ö†Ô∏è No workflow ID provided in URL parameter', 'warning');
          }
          
        } catch (error) {
          console.error('‚ùå Connection failed:', error);
          console.error('‚ùå Full error details:', {
            message: error.message,
            stack: error.stack,
            name: error.name
          });
          
          // Provide specific error messages
          let errorMessage = error.message;
          
          if (error.message.includes('API key') || error.message.includes('401')) {
            errorMessage = 'Invalid API key. Please check your hardcoded API key.';
          } else if (error.message.includes('404') || error.message.includes('not found')) {
            errorMessage = 'n8n API endpoints not found. Please check your n8n instance.';
          } else if (error.message.includes('Failed to fetch')) {
            errorMessage = 'Network error: Cannot reach n8n instance. Check CORS proxy and n8n URL.';
          }
          
          this.showStatus(`‚ùå ${errorMessage}`, 'error');
          this.isConnected = false;
        }
      }
      

      
      async testConnection() {
        // Try different API endpoints to detect n8n version and capabilities
        const endpoints = [
          '/api/v1/workflows', // n8n v1+
          '/rest/workflows',   // older versions
        ];
        
        const urlsToTry = [this.baseN8nUrl, this.corsProxyUrl];
        
        console.log('üîç Testing connection endpoints:', endpoints);
        console.log('üåê URLs to try:', urlsToTry);
        
        for (const baseUrl of urlsToTry) {
          console.log(`üéØ Trying base URL: ${baseUrl}`);
          this.n8nUrl = baseUrl;
        
        for (const endpoint of endpoints) {
          try {
              const fullUrl = `${baseUrl}${endpoint}?limit=1`;
              console.log(`üåê Trying endpoint: ${fullUrl}`);
              console.log(`üîë Using API key header: X-N8N-API-KEY`);
              
            // Simple GET request to avoid CORS preflight
              const response = await fetch(fullUrl, {
              method: 'GET',
              headers: {
                'X-N8N-API-KEY': this.apiKey
              }
            });
              
              console.log(`üì° Response status: ${response.status} ${response.statusText}`);
              console.log(`üì° Response headers:`, Object.fromEntries(response.headers.entries()));
            
            if (response.ok) {
                console.log(`‚úÖ Successfully connected using URL: ${baseUrl} and endpoint: ${endpoint}`);
              return endpoint;
            } else if (response.status === 401) {
                console.log('‚ùå 401 Unauthorized - API key is invalid or insufficient permissions');
              throw new Error('Invalid API key or insufficient permissions');
              } else {
                console.log(`‚ö†Ô∏è Unexpected status ${response.status}, trying next endpoint`);
                const responseText = await response.text();
                console.log(`üìÑ Response body:`, responseText);
            }
          } catch (error) {
              console.error(`‚ùå Error with ${baseUrl}${endpoint}:`, error);
              
              // If this is a CORS error and we're using direct URL, try CORS proxy
              if (error.message.includes('CORS') || error.message.includes('Failed to fetch')) {
                console.log(`‚ö†Ô∏è CORS/Network error with direct URL, will try CORS proxy next`);
            continue;
              }
              
              if (error.message.includes('API key') || error.message.includes('401')) {
                throw error; // Re-throw authentication errors
              }
              
              // For other errors, try next endpoint
              console.warn(`‚ö†Ô∏è Failed to connect to ${baseUrl}${endpoint}:`, error.message);
              continue;
            }
          }
          
          console.log(`‚ö†Ô∏è All endpoints failed for ${baseUrl}, trying next URL...`);
        }
        
        console.error('‚ùå All URLs and endpoints failed');
        throw new Error('Could not connect to n8n instance. Check URL, API key, and CORS configuration.');
      }
      

      
      // Workflow loading methods removed - using URL parameter instead
      
      async loadWorkflow(workflowId) {
        if (!workflowId) {
          this.currentWorkflow = null;
          this.elements.preview.removeAttribute('workflow');
          this.elements.editWorkflowBtn.disabled = true;
          return;
        }
        
        try {
          const workflow = await this.makeApiCall(`/api/v1/workflows/${workflowId}`);
          this.currentWorkflow = workflow;
          
          // Force preview refresh to ensure display
          this.forcePreviewRefresh();
          
          // Update preview with workflow data
          this.elements.preview.setAttribute('workflow', JSON.stringify(workflow));
          
          // Enable edit button
          this.elements.editWorkflowBtn.disabled = false;
          
          this.showStatus(`‚úÖ Loaded and displayed workflow: ${workflow.name}`, 'success');
          console.log('üéØ Workflow automatically loaded and displayed in preview');
          
        } catch (error) {
          console.error('Failed to load workflow:', error);
          this.showStatus(`‚ùå Failed to load workflow: ${error.message}`, 'error');
        }
      }
      
      // Save functionality has been removed - workflows are view-only
      
      // Change detection and auto-save functionality removed - workflows are view-only
      
      // Change tracking methods removed - workflows are view-only
      
      // Refresh methods removed - using refreshAndReload instead
      
      async makeApiCall(endpoint, options = {}) {
        const url = `${this.n8nUrl}${endpoint}`;
        const method = options.method || 'GET';
        
        // Build minimal headers to avoid CORS preflight
        const headers = {
          'X-N8N-API-KEY': this.apiKey
        };
        
        // Only add Content-Type for requests with body
        if (method !== 'GET' && method !== 'HEAD' && options.body) {
          headers['Content-Type'] = 'application/json';
        }
        
        // Add any custom headers
        if (options.headers) {
          Object.assign(headers, options.headers);
        }
        
        const fetchOptions = {
          method,
          headers,
          ...options
        };
        
        try {
          const response = await fetch(url, fetchOptions);
          
          if (!response.ok) {
            let errorText;
            try {
              const errorJson = await response.json();
              console.log('API Error Response:', errorJson);
              errorText = errorJson.message || JSON.stringify(errorJson, null, 2);
            } catch {
              errorText = await response.text();
            }
            
            // Provide specific guidance for common errors
            if (response.status === 400) {
              console.error('400 Error Details:', errorText);
              if (errorText.includes('additional properties')) {
                errorText = 'Invalid workflow data format. Some properties are not allowed in the API request.';
              }
            }
            
            throw new Error(`API call failed (${response.status}): ${errorText}`);
          }
          
          // Handle empty responses
          const contentType = response.headers.get('content-type');
          if (contentType && contentType.includes('application/json')) {
            return await response.json();
          } else {
            return {};
          }
        } catch (error) {
          // Provide better error messages for common issues
          if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
            throw new Error('Network error: Check CORS configuration or internet connection');
          }
          throw error;
        }
      }
      
      // enableWorkflowControls method removed - no dropdown to control
      

      
      showStatus(message, type = 'success') {
        const status = this.elements.statusMsg;
        status.textContent = message;
        status.className = `status ${type}`;
        status.style.display = 'block';
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
          status.style.display = 'none';
        }, 5000);
      }
      

      
      initializePreviewSizing() {
        const sizePreview = () => {
          const preview = this.elements.preview;
          const statusMsg = document.getElementById('statusMsg');
      const footer = document.querySelector('footer');
          const pad = 16; // --pad value
          
          // Calculate used space (only footer + status message if visible + padding)
          const statusHeight = (statusMsg && statusMsg.style.display !== 'none') ? statusMsg.offsetHeight : 0;
          const used = footer.offsetHeight + statusHeight + (pad * 2);
          const availableHeight = Math.max(500, window.innerHeight - used);
          
          preview.style.height = availableHeight + 'px';
        };
        
    window.addEventListener('load', sizePreview);
    window.addEventListener('resize', sizePreview);

        // Initial size after a short delay to ensure DOM is ready
        setTimeout(sizePreview, 100);
      }
    }
    
    // Initialize the editor when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      window.n8nEditor = new N8nDynamicEditor();
    });
    
    // Fallback for older browsers
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        if (!window.n8nEditor) {
          window.n8nEditor = new N8nDynamicEditor();
        }
      });
    } else {
      window.n8nEditor = new N8nDynamicEditor();
    }
    
    // Cleanup removed - no change detection to clean up
    
    // Unsaved changes warning removed - workflows are view-only
  </script>
</body>
</html>

